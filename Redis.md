> 参考 https://zhuanlan.zhihu.com/p/419224864
## Redis是什么
+ C语言编写的Key-Value内存数据库
+ (6.0以前)单线程，一个线程处理所有网络请求。减少线程切换开销，减少锁、竞争
> 6.0后是多线程。单线程仅仅指网络请求处理，其他功能的话有其他线程
+ 支持多种数据类型String、Hash、Set、List等
+ 持久化有RDB(定期快照)和AOF(存命令历史)
+ 支持事务
+ 单个操作是原子性的
+ 支持主从复制。可以读写分离，即，读写可以采用不同机器不同进程
+ 高并发：单个Redis实例支持10万QPS

## Redis为什么快
+ 基于内存，(相对硬盘)读写速度快
+ (6.0以前)单线程实现，避免线程切换开销，避免锁资源争用
+ IO多路复用，通过事件机制轮询描述符
+ 高效的数据结构设计

## 6.0以前为什么用单线程
+ 实现简单，容易维护
+ 避免线程切换开销，避免锁资源争用

## 为什么6.0后引入多线程
+ 利用CPU的多核优势
+ 分摊同步IO的读写时间。如，DEL一个大key
> 难道不是开发者有空改成多线程了，之前没空？

## Redis的用途
+ 作为缓存。缓存热数据
+ 作为消息队列，MQ
+ 作为计数器，因为天然就有原子性。因此也可以是秒杀场景的限速器
+ 提供集合功能，如好友列表

## 为什么不用Memcached
+ redis更易用，功能更多，速度又快的多

## 数据类型
+ **String: 可以是字符串、数字或者二进制**
+ Hash: 一个键值对集合
+ Set: 无序去重的集合。Set 提供了交集、并集
+ List: 有序可重复的集合，底层是依赖双向链表实现的
+ SortedSet:有序Set, 适用于排行榜和带权重的消息队列等场景
+ Bitmap: 位图
+ Hyperloglog: 基数统计的算法,可以统计独立访客数
+ Geospatial: 要用于存储地理位置信息
+ **Rejson: 提供json类型**

## pipeline
+ 批量请求，批量获得结果
+ 节省多次网络包封装，多次网络包发送接收
+ 一个pipeline中命令数量也不要太多

## 事务
+ 使用multi开启，exec提交
+ 一个事务范围内某个命令出错不会影响其他命令的执行，不保证原子性
+ 批量操作在发送 EXEC 命令前被放入队列缓存
+ 在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中
```
multi
set a 1
set b 1 2
set c 3
exec
```

## 持久化
+ RDB方式：定期或手动快照为dump.rdb磁盘文件。是fork父进程出子进程实现的，之后子进程将内存内容写硬盘，fork时会阻塞，因此要避免频繁做持久化
+ AOF:Append only file， 以独立日志的方式记录每次“写命令”
> RDB方式只能恢复到上次持久化的；AOF可以恢复所有数据，但是恢复慢，且存储文件大

## 主从复制
+ 主数据库可以进行读写操作
+ 当主数据库的数据发生变化时会自动将数据同步到从数据库
+ 从数据库一般是只读的
+ 一个主数据库可以有多个从数据库，而一个从数据库只能有一个主数据库
+ 原理：第一次同步是RDB文件，后续是同步“写命令”

## 哨兵Sentinel
+ 定期ping各个Master和Slave(主从)
+ 超时得不到pong就选举出新的Master

## Redis Cluster 高可用
+ 最小配置6个节点以上（3主3从），其中主节点提供读写操作，从节点作为备用节点，不提供请求，只作为故障转移使用
+ 采用虚拟槽分区，所有的键根据哈希函数映射到0～16383个整数槽内，每个节点负责维护一部分槽以及槽所映射的键值数据
+ 可以动态扩容
+ 不支持pipeline
> 在客户端是依然支持pipeline的，可以将pipeline进行拆分，拆分到不同节点上各自执行
+ 数据通过异步复制，不保证数据的强一致性
+ 不支持多数据库空间，单机下的Redis可以支持到16个数据库，集群模式下只能使用1个数据库空间

## 过期键的删除
+ **被动删除**。在访问key时，如果发现key已经过期，那么会将key删除。
+ **主动删除**。定时清理key，每次清理会依次遍历所有DB，从db随机取出20个key，如果过期就删除，如果其中有5个key过期，那么就继续对这个db进行清理，否则开始清理下一个db。
+ **内存不够时清理**。Redis有最大内存的限制，通过maxmemory参数可以设置最大内存，当使用的内存超过了设置的最大内存，就要进行内存释放， 在进行内存释放的时候，会按照配置的淘汰策略清理内存。
> 不要让大量Key同时失效(缓存雪崩)，会拖慢性能


## 缓存更新顺序
> 讨论Redis作为缓存，DB是持久存储
+ 先删缓存，后更新数据库。那么过程中查询可能命中数据库中旧数据
+ 先更新数据库，在删缓存。那么过程中查询可能命中缓存中就数据
+ 异步更新缓存。数据库更新后，加入MQ，缓存从MQ中消费更新
+ 缓存穿透：传了大量不存在的值，导致穿到了DB里，DB里也不存在。解决，可以用布隆过滤器先拦一下
+ 缓存雪崩：大量(存在的)key同时过期，大量落到DB。解决，设置TTL时可以加随机值
+ 缓存击穿：大量请求同时查一个key，而这个key在缓存中过期了，就都去查DB了。解决，加分布式锁，第一个请求可以拿到数据写入到缓存中


## 大Key问题
+ 可以通过内置的bigkey工具扫描到，也可以观察qps、访问延时得知
+ 可以删除大key，string类型的可以做压缩，list、set类型的可以分成多段，hash类型的可以取模分多个小key



