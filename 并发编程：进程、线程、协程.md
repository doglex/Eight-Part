## 什么是并发编程(异步)
+ 并发编程将软件看做任务和资源的组合，那么任务之间竞争和共享资源，当资源满足时执行任务，否则等待资源。
+ 合理的安排调度顺序，从而减少总的运行耗时。
+ 只是为了提高资源利用率，需要操作系统层面提供支持。

## 并发(Concurrent)或并行(Parallel)
+ 并发是指运行顺序“可打乱，可打断”，即，不会卡在一个任务上的能力。可以先把时间片交出去。
+ 并行是指多个任务真的在同时运行，那么是要求多核了。
+ 理解：并发和并行都可以多线程，单CPU是并发，多CPU是并行。

## 进程（Process）、线程(Thread)、协程(coroutine,goroutine,event)
+ **进程**是**CPU资源分配**的最小单位，**线程**是**CPU调度**的最小单位。
+ 进程和线程都是一个时间段的描述，是CPU工作时间段的描述，不过是颗粒大小不同，线程细化了而已
+ 线程的**生命周期**的五种状态：New、Runnable、Running、**Blocked阻塞**（Waiting、Locked、Sleeping）、Dead

## 为什么更喜欢用协程而不是线程
+ 协程是程序员可控的顺序切换(yield/next)，多线程是直接交给OS去调度
+ 协程(也叫纤程)更加轻量，可以开成千上万个都没问题

## 线程安全
+ **原子性**：要么一起不执行，要么一起执行。
比如执行到一半，寄存器上的值又被另一个线程覆盖了，那样就不安全了。
+ **一致性**:一个函数被多个并发线程反复调用时，要一直产生正确的结果。
+ 线程安全的解决办法：在共享(全局)变量上加锁。
+ **可重入性**:打断后回来能保证一致性。这个约束比线程安全要求更高，线程安全只要求一致性。
+ 可重入性的实现：拷贝一份全局变量的值到本地。"并发"程序是要求可重入。


## Js的异步
+ 浏览器的单个页签Js的单线程的，但是支持异步
+ 可以用 async function { await } 支持开启一个异步函数
+ 或者用 Promise 语法
+ 理解：代码写起来和golang中的 go function1() 是差不多的

## Python的异步
### 一、多进程
+ 使用multiprocessing库，是可以利用多核的算力的
+ Pandas库本身是单进程，可以借助swifter第三方库实现多核计算group-apply分组聚合功能
+ 一般可以占满核心，因此有几个核就最多开几个并行度如，pool = Pool(cores)
+ 如果是Tensorflow或者Pytorch的多进程调用，在Windows下可能需要写到__main__下，否则报错

### 二、多线程(不建议)
+ 使用threading库，但是用了之后仍然是单核
+ 因为Cpython是有GIL(全局解释器锁)，所以是假的多线程
+ 虽然一定程度减少IO等待，但是协程更好用
+ 如果如果是写交互界面，何必用Python呢

### 三、协程
+ 可以用Python3.6后提供的标准的async/await但是实在很难写代码。asyncio本质上也只是对yield,yield from,next 等关键词的封装。和C#的异步是相似的
+ 建议直接使用gevent或者greenlet等第三方库，记得用monkey-patch给IO相关标准库(如文件、网络)打补丁。如果是数据库连接要打补丁，可能需要额外处理
+ 从实际效果看，有些OS是不支持gevent的，可以试试greenlet
+ python的协程仍然是在单核的限制范围的，因此也是假协程，不过比多线程轻量得多。而golang的协程是可以使用到多核的

### 四、高性能实践
+ 如果是网站，用uwsgi，如hypercorn、uvicorn、nginx等启动多个worker
+ 自己写代码，可以多进程，每个进程下再开协程
+ 对于CPython，IO密集型优先选gevent协程Pool方案，CPU密集型则一定是选多进程了


## Golang的异步
+ 可以自动调用多核的
+ 只需要用 go xxx即可调起，不用像其他语言写各种await和async
+ GMP模型(即，Actor)：其哲学是“发送数据而不要内存共享”，因此相比其他语言，开异步的内存占用是极低的。
+ (Common Mistake) Golang应该注意在for循环中重新对变量赋值，不然一直是第0个变量。