## 什么是并发编程(异步)
+ 并发编程将软件看做任务和资源的组合，那么任务之间竞争和共享资源，当资源满足时执行任务，否则等待资源。
+ 合理的安排调度顺序，从而减少总的运行耗时。
+ 只是为了提高资源利用率，需要操作系统层面提供支持。

## 并发(Concurrent)或并行(Parallel)
+ 并发是指运行顺序“可打乱，可打断”，即，不会卡在一个任务上的能力。可以先把时间片交出去。
+ 并行是指多个任务真的在同时运行，那么是要求多核了。
+ 理解：并发和并行都可以多线程，单CPU是并发，多CPU是并行。

## 进程（Process）、线程(Thread)、协程(coroutine,goroutine,event)
+ **进程**是**CPU资源分配**的最小单位，**线程**是**CPU调度**的最小单位。
+ 进程和线程都是一个时间段的描述，是CPU工作时间段的描述，不过是颗粒大小不同，线程细化了而已
+ 线程的**生命周期**的五种状态：New、Runnable、Running、**Blocked阻塞**（Waiting、Locked、Sleeping）、Dead

## 为什么更喜欢用协程而不是线程
+ 协程是程序员可控的顺序切换(yield/next)，多线程是直接交给OS去调度
+ 协程(也叫纤程)更加轻量，可以开成千上万个都没问题

## 线程安全
+ **原子性**：要么一起不执行，要么一起执行。
比如执行到一半，寄存器上的值又被另一个线程覆盖了，那样就不安全了。
+ **一致性**:一个函数被多个并发线程反复调用时，要一直产生正确的结果。
+ 线程安全的解决办法：在共享(全局)变量上加锁。
+ **可重入性**:打断后回来能保证一致性。这个约束比线程安全要求更高，线程安全只要求一致性。
+ 可重入性的实现：拷贝一份全局变量的值到本地。"并发"程序是要求可重入。


## Js的异步
+ 浏览器的单个页签Js的单线程的，但是支持异步
+ 可以用 async function { await } 支持开启一个异步函数
+ 或者用 Promise 语法
+ 理解：代码写起来和golang中的 go function1() 是差不多的

## Python的异步
### 一、多进程
+ 使用multiprocessing库，是可以利用多核的算力的
+ Pandas库本身是单进程，可以借助swifter第三方库实现多核计算group-apply分组聚合功能
+ 一般可以占满核心，因此有几个核就最多开几个并行度如，pool = Pool(cores)
+ 如果是Tensorflow或者Pytorch的多进程调用，在Windows下可能需要写到__main__下，否则报错

### 二、多线程(不建议)
+ 使用threading库，但是用了之后仍然是单核
+ 因为Cpython是有GIL(全局解释器锁)，所以是假的多线程
+ 虽然一定程度减少IO等待，但是协程更好用
+ 如果如果是写交互界面，何必用Python呢

### 三、协程
+ 可以用Python3.6后提供的标准的async/await但是实在很难写代码。asyncio本质上也只是对yield,yield from,next 等关键词的封装。和C#的异步是相似的
+ 建议直接使用gevent或者greenlet等第三方库，记得用monkey-patch给IO相关标准库(如文件、网络)打补丁。如果是数据库连接要打补丁，可能需要额外处理
+ 从实际效果看，有些OS是不支持gevent的，可以试试greenlet
+ python的协程仍然是在单核的限制范围的，因此也是假协程，不过比多线程轻量得多。而golang的协程是可以使用到多核的

### 四、高性能实践
+ 如果是网站，用uwsgi，如hypercorn、uvicorn、nginx等启动多个worker
+ 自己写代码，可以多进程，每个进程下再开协程
+ 对于CPython，IO密集型优先选gevent协程Pool方案，CPU密集型则一定是选多进程了


## Golang的异步
+ 可以自动调用多核的
+ 只需要用 go xxx即可调起，不用像其他语言写各种await和async
+ GMP模型(即，Actor)：其哲学是“发送数据而不要内存共享”，因此相比其他语言，开异步的内存占用是极低的。
+ (Common Mistake) Golang应该注意在for循环中重新对变量赋值，不然一直是第0个变量。


## 多线程和多进程
1.多进程和多线程都可以利用多CPU(Python除外)。

2.死锁：在线程间共享多个资源的时候，如果两个线程分别占有一部分资源并且同时等待对方的资源，就会造成死锁。
> 死锁必要条件：(1)互斥(2)请求(3)不可剥夺(4)循环等待
> 死锁解决：破坏任一条件即可。
> 例1：高优先级的任务可以从低优先级任务中抢资源。
> 例2：资源占有太久了就主动释放一下。
> 例3：一直得不到资源就自己结束任务。
> 例4：从一开始就设计好代码不相互干扰。

3.同一进程下的多个线程共享资源：所有进程的数据(而进程是资源分配的最小单元)，包括全局堆、全局变量、静态变量、文件、进程代码段、进程打开的文件描述符、信号的处理器、进程的当前目录、进程的用户ID和进程的组ID。因此**线程切换的开销相对于进程切换是小的**。

4.线程间独有的资源：栈和局部堆(线程的堆栈)、寄存器副本(寄存器组的值)、线程ID、错误返回码、线程的信号屏蔽码、线程优先级。

5.进程间通信（IPC）七种方式：
- 管道(Pipe)：只能半双工，数据单向流动。无名管道只能在父子进程中，有名管道(Named Pipe)可以无亲缘关系。
- 锁/信号量(Semophore)：是一个计数器，作为锁机制，控制多个进程对共享资源的访问。
- 消息队列(Message Queue)：消息的链表。如Kafka、Redis、Mysql等都可实现
- 信号(Signal)：通知接收进程某个事件已经发送。
- 共享内存(Shared Memory)：是最快的IPC。
- 套接字(Socket)：可以跨平台。如docker的sock

6.进程间通信(IPC)的四种技术:
- 消息传递(管道、FIFO、POSIX、System、消息队列)
- 同步(互斥锁、条件变量、读写锁、文件和记录锁、POSIX、System、信号灯)
- 共享内存(匿名共享内存区、有名POSIX、共享内存区，有名System)
- 过程调用(Solaris门、Sun RPC)