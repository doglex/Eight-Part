## 架构
+ 逻辑架构：客户端--连接器(线程)--查询缓存--解析器--优化器--存储引擎
+ 每个客户端连接在服务器进程中有一个线程，该线程在CPU中轮流得到执行
+ 读锁(Read Lock)是共享(shared)的、写锁(Write Lock)是排他(exclusive)的。加锁也需要额外资源
+ 有表锁(table lock)、行级锁(row lock)

## 事务(Transaction，ACID):Atomicity、Consistency、Isolation、Durability
+ 原子性：不可分割，要么一起执行，要么一起不执行
+ 一致性：数据库总是从一个一致性状态到另一个一致性状态
+ 隔离性：一个事务提交前，其他事务不可见
+ 持久性：一旦事务提交，所做的更改永久保存在数据库中

## 隔离级别
+ 未提交读：即使没提交，也被别的事务看到。
+ 提交读：很多数据库默认。
+ 可重复读：阻止脏读。Mysql默认，Mysql的InnoDB也是可以(MVCC)防止幻读的
+ 可串行化：最高隔离级别

## 死锁
+ 两个事务统一资源相互占用，并循环请求对方资源
+ InnoDB有死锁检测和死锁超时机制

## 事务日志
预写式日志，Write-Ahead Logging 

## InnoDB引擎
+ 数据存储在表空间tablespace 
+ 基于聚簇索引建立
+ 用MVCC多版本控制来支持多事物的高并发
+ 有优化，可预测预读等

## 其他引擎
+ MyISAM
+ Archive
+ Blackhole
+ CSV
+ Federated
+ Memory
+ Merge 
+ NDB
+ XtraDB(OLTP)
+ InfoBright(列存储)

## 性能优化
+ 分析服务器负载
+ 分析慢查询
+ explain、 show profile、 show status 

## Schema和数据类型优化
+ 更小的一般更好：如bigint改成int，varchar改成char
+ 避免NULL
+ 不能太多的列
+ 不能太多的关联
+ 范式：同一事实数据出现一次。更新更快
+ 反范式：有冗余的数据，数据可能出现多次。减少关联
+ 物化视图：视图只是查询语句的组合，物化视图是提前计算到磁盘上的表，可以加速查询
+ 加快Alter Table语句：解除事务，解除锁

## 高性能索引
+ B-Tree：默认是这种，适合范围查找、全键值查找、建前缀查找
```
B+树改进：
B+树的非叶子节点不保存具体的数据，而只保存关键字的索引
B+树叶子节点的关键字从小到大有序排列
非叶子节点的子节点数=关键字数
优点：
(1)B+树查询速度更稳定
(2)B+树天然具备排序功能
(3)B+树全节点遍历更快
B*树继续改进：
首先是关键字个数限制问题，B+树初始化的关键字初始化个数是cei(m/2)，b*树的初始化个数为（cei(2/3*m)）
B+树节点满时就会分裂，而B*树节点满时会检查兄弟节点是否满
```
+ Hash-Index：适合精确匹配，仅包含hash值和行指针。访问非常快，除非大量hash冲突。无法排序
+ 空间数据索引 R-Tree
+ 全文索引
+ 需要按照顺序列创建索引，因为有前缀性
+ InnoDB聚簇索引：索引和聚簇行是一起保存的，聚簇或不聚簇是可选的
+ 索引可以帮助加锁时锁定更少的行

## 查询优化
+ 是否查询了过多的行
+ 多表关联是否返回太多列
+ 是否重复查询相同数据
+ 切分查询
+ 分解关联查询（让缓存效率更高）
+ 有时无法自动的谓词下推，需要自己写好子查询条件

## 分区 Partition
> 类似Hive的分区也说得通
+ 可以让单表存储更多的数据。
+ 分区表的数据更容易维护，可以通过清除整个分区批量删除大量数据，也可以增加新的分区来支持新插入的数据。另外，还可以对一个独立分区进行优化、检查、修复等操作。
+ 部分查询能够从查询条件确定只落在少数分区上，查询速度会很快。
+ 分区表的数据还可以分布在不同的物理设备上，从而高效利用多个硬件设备。
+ 可以使用分区表来避免某些特殊瓶颈，例如 InnoDB 单个索引的互斥访问、ext3 文件系统的 inode 锁竞争。
+ 可以备份和恢复单个分区。
+ 一个表最多只能有 1024 个分区。
+ 如果分区字段中有主键或者唯一索引的列，那么所有主键列和唯一索引列都必须包含进来。
+ 分区表无法使用外键约束。
+ NULL 值会使分区过滤无效。
+ 所有分区必须使用相同的存储引擎。